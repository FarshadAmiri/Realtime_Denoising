{% extends "core/base.html" %}

{% block title %}{{ target_user.username }} - Audio Stream{% endblock %}

{% block extra_css %}
<style>
    .user-header {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .user-info h1 {
        font-size: 2rem;
        margin-bottom: 0.5rem;
    }
    
    .status-badge {
        display: inline-block;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-weight: 600;
    }
    
    .status-badge.live {
        background: #e74c3c;
        color: white;
        animation: pulse 2s infinite;
    }
    
    .status-badge.offline {
        background: #95a5a6;
        color: white;
    }
    
    .stream-section {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 2rem;
    }
    
    .stream-section h2 {
        margin-bottom: 1.5rem;
    }
    
    .stream-controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;
    }
    
    .toggle-switch {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .toggle-switch input[type="checkbox"] {
        width: 50px;
        height: 26px;
        appearance: none;
        background: #ccc;
        border-radius: 13px;
        position: relative;
        cursor: pointer;
        transition: background 0.2s;
    }
    
    .toggle-switch input[type="checkbox"]:checked {
        background: #27ae60;
    }
    
    .toggle-switch input[type="checkbox"]::before {
        content: '';
        position: absolute;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: white;
        top: 2px;
        left: 2px;
        transition: left 0.2s;
    }
    
    .toggle-switch input[type="checkbox"]:checked::before {
        left: 26px;
    }
    
    .timer {
        font-size: 1.5rem;
        font-weight: 600;
        font-family: 'Courier New', monospace;
        color: #e74c3c;
    }
    
    .recordings-section {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .recordings-section h2 {
        margin-bottom: 1.5rem;
    }
    
    .recording-item {
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 6px;
        margin-bottom: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .recording-info {
        flex: 1;
    }
    
    .recording-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
    }
    
    .recording-meta {
        font-size: 0.875rem;
        color: #666;
    }
    
    .recording-actions {
        display: flex;
        gap: 0.5rem;
    }
    
    audio {
        max-width: 300px;
    }
    
    .no-recordings {
        text-align: center;
        color: #666;
        padding: 2rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="user-header">
    <div class="user-info">
        <h1>{{ target_user.username }}</h1>
        <span class="status-badge {% if is_streaming %}live{% else %}offline{% endif %}" id="status-badge">
            {% if is_streaming %}üî¥ LIVE{% else %}‚ö´ Offline{% endif %}
        </span>
    </div>
    <div>
        <a href="{% url 'main_page' %}" class="btn btn-primary">‚Üê Back to Home</a>
    </div>
</div>

<div class="stream-section">
    <h2>{% if is_owner %}My Stream{% else %}Live Stream{% endif %}</h2>
    
    {% if is_owner %}
        <!-- Broadcaster controls -->
        <div class="stream-controls">
            <button id="start-btn" class="btn btn-success" onclick="startStream()">Start Streaming</button>
            <button id="stop-btn" class="btn btn-danger" onclick="stopStream()" style="display: none;">Stop Streaming</button>
            
            <div class="toggle-switch">
                <label for="denoise-toggle">Enable Denoise:</label>
                <input type="checkbox" id="denoise-toggle" checked>
            </div>
            
            <div class="timer" id="timer">00:00</div>
        </div>
        
        <div id="stream-status" style="margin-top: 1rem; color: #666;"></div>
    {% else %}
        <!-- Listener controls -->
        <div id="listener-section">
            {% if is_streaming %}
                <button id="listen-btn" class="btn btn-primary" onclick="startListening()">Start Listening</button>
                <button id="stop-listen-btn" class="btn btn-danger" onclick="stopListening()" style="display: none;">Stop Listening</button>
                <div style="margin-top: 1rem;">
                    <audio id="remote-audio" autoplay controls style="display: none;"></audio>
                </div>
                <div id="listen-status" style="margin-top: 1rem; color: #666;"></div>
            {% else %}
                <p style="color: #666;">{{ target_user.username }} is not currently streaming.</p>
            {% endif %}
        </div>
    {% endif %}
</div>

<div class="recordings-section">
    <h2>Recordings</h2>
    
    {% if recordings %}
        <div id="recordings-list">
            {% for recording in recordings %}
            <div class="recording-item">
                <div class="recording-info">
                    <div class="recording-title">{{ recording.title }}</div>
                    <div class="recording-meta">
                        Duration: {{ recording.get_duration_display }} | 
                        {{ recording.created_at|date:"M d, Y H:i" }} |
                        {% if recording.denoise_enabled %}‚úì Denoised{% else %}Raw{% endif %}
                    </div>
                </div>
                <div class="recording-actions">
                    {% if recording.file %}
                    <audio controls preload="none">
                        <source src="{{ recording.file.url }}" type="audio/wav">
                    </audio>
                    {% else %}
                    <span style="color:#999;">No file</span>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        </div>
    {% else %}
        <div class="no-recordings">
            <p>No recordings yet.</p>
        </div>
    {% endif %}
</div>
{% endblock %}

{% block extra_js %}
<script>
    const isOwner = {{ is_owner|yesno:"true,false" }};
    const username = "{{ target_user.username }}";
    const currentUser = "{{ user.username }}";
    const browserAudioProcessing = {{ browser_audio_processing|yesno:"true,false" }};
    
    let peerConnection = null;
    let localStream = null;
    let timerInterval = null;
    let startTime = null;
    let presenceSocket = null;
    
    // WebSocket for presence
    function connectPresence() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        presenceSocket = new WebSocket(protocol + '//' + window.location.host + '/ws/presence/');
        
        presenceSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            
            if (data.type === 'streaming_status_update' && data.username === username) {
                updateStatusBadge(data.is_streaming);
                
                if (!isOwner) {
                    // Update listener section based on streaming status
                    if (data.is_streaming) {
                        showListenerControls();
                    } else {
                        hideListenerControls();
                    }
                }
            }
        };
        
        presenceSocket.onerror = function(e) {
            console.error('Presence WebSocket error:', e);
        };
        
        presenceSocket.onclose = function() {
            setTimeout(connectPresence, 3000);
        };
    }
    
    function updateStatusBadge(isStreaming) {
        const badge = document.getElementById('status-badge');
        if (isStreaming) {
            badge.className = 'status-badge live';
            badge.textContent = 'üî¥ LIVE';
        } else {
            badge.className = 'status-badge offline';
            badge.textContent = '‚ö´ Offline';
        }
    }
    
    function showListenerControls() {
        const section = document.getElementById('listener-section');
        section.innerHTML = `
            <button id="listen-btn" class="btn btn-primary" onclick="startListening()">Start Listening</button>
            <button id="stop-listen-btn" class="btn btn-danger" onclick="stopListening()" style="display: none;">Stop Listening</button>
            <div style="margin-top: 1rem;">
                <audio id="remote-audio" autoplay controls style="display: none;"></audio>
            </div>
            <div id="listen-status" style="margin-top: 1rem; color: #666;"></div>
        `;
    }
    
    function hideListenerControls() {
        const section = document.getElementById('listener-section');
        section.innerHTML = `<p style="color: #666;">${username} is not currently streaming.</p>`;
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
    }
    
    // Timer functions
    function startTimer() {
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
    }
    
    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }
    
    function updateTimer() {
        if (!startTime) return;
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('timer').textContent = 
            String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
    }
    
    // Helper: wait for ICE gathering to complete (non-trickle)
    function waitForIceGathering(pc) {
        return new Promise(resolve => {
            if (pc.iceGatheringState === 'complete') {
                resolve();
            } else {
                function checkState() {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', checkState);
                        resolve();
                    }
                }
                pc.addEventListener('icegatheringstatechange', checkState);
            }
        });
    }

    // Broadcaster functions
    async function startStream() {
        try {
            document.getElementById('stream-status').textContent = 'Starting stream...';
            
            const denoise = document.getElementById('denoise-toggle').checked;
            
            // Call API to start stream
            const response = await fetch('/api/stream/start/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken'),
                },
                body: JSON.stringify({ denoise: denoise }),
            });
            
            if (!response.ok) {
                throw new Error('Failed to start stream');
            }
            
            const data = await response.json();
            
            // Get microphone access (48k mono; processing toggle from settings)
            localStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    channelCount: { ideal: 1 },
                    sampleRate: { ideal: 48000 },
                    echoCancellation: browserAudioProcessing,
                    noiseSuppression: browserAudioProcessing,
                    autoGainControl: browserAudioProcessing,
                }, 
                video: false 
            });

            // Create RTCPeerConnection and add audio track
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
            });
            // Add track and try to increase sender bitrate for better quality
            localStream.getTracks().forEach(track => {
                const sender = peerConnection.addTrack(track, localStream);
                try {
                    const params = sender.getParameters();
                    if (!params.encodings) params.encodings = [{}];
                    // 192 kbps target; browsers may clamp
                    params.encodings[0].maxBitrate = 192000; 
                    sender.setParameters(params);
                } catch (e) {
                    // Some browsers may not allow setParameters; ignore
                    console.warn('Could not set sender params:', e);
                }
            });
            
            // Create SDP offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            await waitForIceGathering(peerConnection);
            
            // Send offer to server and set answer
            const offerResp = await fetch('/api/stream/offer/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken'),
                },
                body: JSON.stringify({ sdp: peerConnection.localDescription.sdp }),
            });
            if (!offerResp.ok) {
                throw new Error('Failed to negotiate WebRTC');
            }
            const answerData = await offerResp.json();
            await peerConnection.setRemoteDescription({ type: 'answer', sdp: answerData.sdp });
            
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'inline-block';
            document.getElementById('denoise-toggle').disabled = true;
            document.getElementById('stream-status').textContent = 'Streaming...';
            
            startTimer();
            
        } catch (error) {
            console.error('Error starting stream:', error);
            document.getElementById('stream-status').textContent = 'Error: ' + error.message;
        }
    }
    
    async function stopStream() {
        try {
            // Close peer connection
            if (peerConnection) {
                try { peerConnection.getSenders().forEach(s => s.track && s.track.stop()); } catch (e) {}
                try { peerConnection.close(); } catch (e) {}
                peerConnection = null;
            }

            // Stop tracks
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            stopTimer();
            
            // Calculate duration
            const duration = startTime ? (Date.now() - startTime) / 1000 : 0;
            
            // Call API to stop stream
            const response = await fetch('/api/stream/stop/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken'),
                },
                body: JSON.stringify({ duration: duration }),
            });
            
            if (!response.ok) {
                throw new Error('Failed to stop stream');
            }
            
            document.getElementById('start-btn').style.display = 'inline-block';
            document.getElementById('stop-btn').style.display = 'none';
            document.getElementById('denoise-toggle').disabled = false;
            document.getElementById('stream-status').textContent = 'Stream stopped.';
            document.getElementById('timer').textContent = '00:00';
            
            // Reload page to show new recording
            setTimeout(() => location.reload(), 2000);
            
        } catch (error) {
            console.error('Error stopping stream:', error);
            document.getElementById('stream-status').textContent = 'Error: ' + error.message;
        }
    }
    
    // Listener functions
    async function startListening() {
        try {
            document.getElementById('listen-status').textContent = 'Connecting...';
            document.getElementById('listen-btn').style.display = 'none';
            document.getElementById('stop-listen-btn').style.display = 'inline-block';
            
            // Create RTCPeerConnection
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
            });
            const remoteAudio = document.getElementById('remote-audio');
            peerConnection.addEventListener('track', (event) => {
                if (remoteAudio.srcObject !== event.streams[0]) {
                    remoteAudio.srcObject = event.streams[0];
                    remoteAudio.style.display = 'block';
                    // Try autoplay in case browser blocks it
                    const playAttempt = remoteAudio.play();
                    if (playAttempt && playAttempt.catch) {
                        playAttempt.catch(() => {/* ignore */});
                    }
                }
            });
            // Request recvonly audio
            peerConnection.addTransceiver('audio', { direction: 'recvonly' });

            // Create offer and wait for ICE gathering
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            await waitForIceGathering(peerConnection);

            // Send offer to server for listener
            const resp = await fetch(`/api/stream/listener/${encodeURIComponent(username)}/offer/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken'),
                },
                body: JSON.stringify({ sdp: peerConnection.localDescription.sdp }),
            });
            if (!resp.ok) {
                throw new Error('Failed to negotiate listen connection');
            }
            const answer = await resp.json();
            await peerConnection.setRemoteDescription({ type: 'answer', sdp: answer.sdp });

            document.getElementById('listen-status').textContent = 'Listening to live stream...';
            
        } catch (error) {
            console.error('Error starting listening:', error);
            document.getElementById('listen-status').textContent = 'Error: ' + error.message;
        }
    }
    
    function stopListening() {
        if (peerConnection) {
            try { peerConnection.close(); } catch (e) {}
            peerConnection = null;
        }
        
        document.getElementById('listen-btn').style.display = 'inline-block';
        document.getElementById('stop-listen-btn').style.display = 'none';
        document.getElementById('remote-audio').style.display = 'none';
        document.getElementById('listen-status').textContent = '';
    }
    
    // Utility functions
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    // Handle page unload (send beacon to stop stream)
    window.addEventListener('beforeunload', function() {
        if (isOwner && localStream) {
            navigator.sendBeacon('/api/stream/stop/', JSON.stringify({}));
        }
    });
    
    // Connect presence WebSocket
    connectPresence();
</script>
{% endblock %}
